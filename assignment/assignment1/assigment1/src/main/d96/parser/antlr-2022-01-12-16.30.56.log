2022-01-12 16:30:56:372 grammar LogManager.java:25 before: (COMBINED_GRAMMAR D96 (@ lexer header {
from lexererr import *
}) (RULES (RULE init (BLOCK (ALT LEFT_CURLY_BRACKET value (* (BLOCK (ALT COMMA value))) RIGHT_CURLY_BRACKET))) (RULE value (BLOCK (ALT init) (ALT TEST))) (RULE TEST (BLOCK (ALT (+ (BLOCK (ALT DECIMAL_DIGIT)))))) (RULE WHITE_SPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '##' (* (BLOCK (ALT .))) '##') skip))) (RULE BREAK (BLOCK (ALT 'Break'))) (RULE CONTINUE (BLOCK (ALT 'Continue'))) (RULE IF (BLOCK (ALT 'If'))) (RULE ELSE_IF (BLOCK (ALT 'Elseif'))) (RULE ELSE (BLOCK (ALT 'Else'))) (RULE FOR_EACH (BLOCK (ALT 'Foreach'))) (RULE TRUE (BLOCK (ALT 'True'))) (RULE FALSE (BLOCK (ALT 'False'))) (RULE ARRAY (BLOCK (ALT 'Array'))) (RULE IN (BLOCK (ALT 'In'))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOLEAN (BLOCK (ALT 'Boolean'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE RETURN (BLOCK (ALT 'Return'))) (RULE NULL (BLOCK (ALT 'Null'))) (RULE CLASS (BLOCK (ALT 'Class'))) (RULE VAL (BLOCK (ALT 'Val'))) (RULE VAR (BLOCK (ALT 'Var'))) (RULE CONSTRUCTOR (BLOCK (ALT 'Constructor'))) (RULE DESTRUCTOR (BLOCK (ALT 'Destructor'))) (RULE NEW (BLOCK (ALT 'New'))) (RULE BY (BLOCK (ALT 'By'))) (RULE LEFT_PAREN (BLOCK (ALT '('))) (RULE RIGHT_PAREN (BLOCK (ALT ')'))) (RULE LEFT_SQUARE_BRACKET (BLOCK (ALT '['))) (RULE RIGHT_SQUARE_BRACKET (BLOCK (ALT ']'))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE LEFT_CURLY_BRACKET (BLOCK (ALT '{'))) (RULE RIGHT_CURLY_BRACKET (BLOCK (ALT '}'))) (RULE SINGLE_QUOTE (RULEMODIFIERS fragment) (BLOCK (ALT '\''))) (RULE DOUBLE_QUOTE (RULEMODIFIERS fragment) (BLOCK (ALT '"'))) (RULE ESCAPE (BLOCK (ALT '\\' (BLOCK (ALT [bfrnt'"]) (ALT '\\'))))) (RULE OCTAL_NOTATION (RULEMODIFIERS fragment) (BLOCK (ALT '0'))) (RULE HEXA_NOTATION (RULEMODIFIERS fragment) (BLOCK (ALT '0x') (ALT '0X'))) (RULE BINARY_NOTATION (RULEMODIFIERS fragment) (BLOCK (ALT '0b') (ALT '0B'))) (RULE OCTAL_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9a-fA-F]))) (RULE HEXA_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-7]))) (RULE BINARY_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-1]))) (RULE DECIMAL_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE EXPONENT (RULEMODIFIERS fragment) (BLOCK (ALT [eE] (? (BLOCK (ALT [-+]))) (+ (BLOCK (ALT DECIMAL_DIGIT)))))) (RULE INTEGER (BLOCK (ALT (? (BLOCK (ALT [-+]))) (BLOCK (ALT '0') (ALT [1-9] (* (BLOCK (ALT DECIMAL_DIGIT) (ALT '_'))))) {self.text = self.text.replace("_", "")}))) (RULE OCTAL_LITERALNESS (BLOCK (ALT OCTAL_NOTATION OCTAL_DIGIT))) (RULE HEXA_LITERALNESS (BLOCK (ALT HEXA_NOTATION HEXA_DIGIT))) (RULE BINARY_LITERALNESS (BLOCK (ALT BINARY_NOTATION BINARY_DIGIT))) (RULE FLOAT_LITERALNESS (BLOCK (ALT (+ (BLOCK (ALT INTEGER))) DOT (* (BLOCK (ALT DECIMAL_DIGIT))) (? (BLOCK (ALT EXPONENT)))) (ALT (+ (BLOCK (ALT INTEGER))) (? (BLOCK (ALT EXPONENT)))) (ALT DOT (+ (BLOCK (ALT DECIMAL_DIGIT))) (? (BLOCK (ALT EXPONENT)))))) (RULE BOOLEAN_LITERALNESS (BLOCK (ALT TRUE) (ALT FALSE))) (RULE STRING_LITERALNESS (BLOCK (ALT DOUBLE_QUOTE (* (BLOCK (ALT ESCAPE) (ALT .))) DOUBLE_QUOTE))) (RULE ERROR_CHAR (BLOCK (ALT . {raise ErrorToken (self.text)}))) (RULE UNCLOSE_STRING (BLOCK (ALT .))) (RULE ILLEGAL_ESCAPE (BLOCK (ALT .)))))
2022-01-12 16:30:56:418 grammar LogManager.java:25 after: (COMBINED_GRAMMAR D96 (@ lexer header {
from lexererr import *
}) (RULES (RULE init (BLOCK (ALT LEFT_CURLY_BRACKET value (* (BLOCK (ALT COMMA value))) RIGHT_CURLY_BRACKET))) (RULE value (BLOCK (ALT init) (ALT TEST))) (RULE TEST (BLOCK (ALT (+ (BLOCK (ALT DECIMAL_DIGIT)))))) (RULE WHITE_SPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '##' (* (BLOCK (ALT .))) '##') skip))) (RULE BREAK (BLOCK (ALT 'Break'))) (RULE CONTINUE (BLOCK (ALT 'Continue'))) (RULE IF (BLOCK (ALT 'If'))) (RULE ELSE_IF (BLOCK (ALT 'Elseif'))) (RULE ELSE (BLOCK (ALT 'Else'))) (RULE FOR_EACH (BLOCK (ALT 'Foreach'))) (RULE TRUE (BLOCK (ALT 'True'))) (RULE FALSE (BLOCK (ALT 'False'))) (RULE ARRAY (BLOCK (ALT 'Array'))) (RULE IN (BLOCK (ALT 'In'))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOLEAN (BLOCK (ALT 'Boolean'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE RETURN (BLOCK (ALT 'Return'))) (RULE NULL (BLOCK (ALT 'Null'))) (RULE CLASS (BLOCK (ALT 'Class'))) (RULE VAL (BLOCK (ALT 'Val'))) (RULE VAR (BLOCK (ALT 'Var'))) (RULE CONSTRUCTOR (BLOCK (ALT 'Constructor'))) (RULE DESTRUCTOR (BLOCK (ALT 'Destructor'))) (RULE NEW (BLOCK (ALT 'New'))) (RULE BY (BLOCK (ALT 'By'))) (RULE LEFT_PAREN (BLOCK (ALT '('))) (RULE RIGHT_PAREN (BLOCK (ALT ')'))) (RULE LEFT_SQUARE_BRACKET (BLOCK (ALT '['))) (RULE RIGHT_SQUARE_BRACKET (BLOCK (ALT ']'))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE LEFT_CURLY_BRACKET (BLOCK (ALT '{'))) (RULE RIGHT_CURLY_BRACKET (BLOCK (ALT '}'))) (RULE SINGLE_QUOTE (RULEMODIFIERS fragment) (BLOCK (ALT '\''))) (RULE DOUBLE_QUOTE (RULEMODIFIERS fragment) (BLOCK (ALT '"'))) (RULE ESCAPE (BLOCK (ALT '\\' (BLOCK (ALT [bfrnt'"]) (ALT '\\'))))) (RULE OCTAL_NOTATION (RULEMODIFIERS fragment) (BLOCK (ALT '0'))) (RULE HEXA_NOTATION (RULEMODIFIERS fragment) (BLOCK (ALT '0x') (ALT '0X'))) (RULE BINARY_NOTATION (RULEMODIFIERS fragment) (BLOCK (ALT '0b') (ALT '0B'))) (RULE OCTAL_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9a-fA-F]))) (RULE HEXA_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-7]))) (RULE BINARY_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-1]))) (RULE DECIMAL_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE EXPONENT (RULEMODIFIERS fragment) (BLOCK (ALT [eE] (? (BLOCK (ALT [-+]))) (+ (BLOCK (ALT DECIMAL_DIGIT)))))) (RULE INTEGER (BLOCK (ALT (? (BLOCK (ALT [-+]))) (BLOCK (ALT '0') (ALT [1-9] (* (BLOCK (ALT DECIMAL_DIGIT) (ALT '_'))))) {self.text = self.text.replace("_", "")}))) (RULE OCTAL_LITERALNESS (BLOCK (ALT OCTAL_NOTATION OCTAL_DIGIT))) (RULE HEXA_LITERALNESS (BLOCK (ALT HEXA_NOTATION HEXA_DIGIT))) (RULE BINARY_LITERALNESS (BLOCK (ALT BINARY_NOTATION BINARY_DIGIT))) (RULE FLOAT_LITERALNESS (BLOCK (ALT (+ (BLOCK (ALT INTEGER))) DOT (* (BLOCK (ALT DECIMAL_DIGIT))) (? (BLOCK (ALT EXPONENT)))) (ALT (+ (BLOCK (ALT INTEGER))) (? (BLOCK (ALT EXPONENT)))) (ALT DOT (+ (BLOCK (ALT DECIMAL_DIGIT))) (? (BLOCK (ALT EXPONENT)))))) (RULE BOOLEAN_LITERALNESS (BLOCK (ALT TRUE) (ALT FALSE))) (RULE STRING_LITERALNESS (BLOCK (ALT DOUBLE_QUOTE (* (BLOCK (ALT ESCAPE) (ALT .))) DOUBLE_QUOTE))) (RULE ERROR_CHAR (BLOCK (ALT . {raise ErrorToken (self.text)}))) (RULE UNCLOSE_STRING (BLOCK (ALT .))) (RULE ILLEGAL_ESCAPE (BLOCK (ALT .)))))
2022-01-12 16:30:56:456 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR D96 (RULES (RULE init (BLOCK (ALT LEFT_CURLY_BRACKET value (* (BLOCK (ALT COMMA value))) RIGHT_CURLY_BRACKET))) (RULE value (BLOCK (ALT init) (ALT TEST)))))
2022-01-12 16:30:56:456 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR D96Lexer (@ lexer header {
from lexererr import *
}) (RULES (RULE TEST (BLOCK (ALT (+ (BLOCK (ALT DECIMAL_DIGIT)))))) (RULE WHITE_SPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '##' (* (BLOCK (ALT .))) '##') skip))) (RULE BREAK (BLOCK (ALT 'Break'))) (RULE CONTINUE (BLOCK (ALT 'Continue'))) (RULE IF (BLOCK (ALT 'If'))) (RULE ELSE_IF (BLOCK (ALT 'Elseif'))) (RULE ELSE (BLOCK (ALT 'Else'))) (RULE FOR_EACH (BLOCK (ALT 'Foreach'))) (RULE TRUE (BLOCK (ALT 'True'))) (RULE FALSE (BLOCK (ALT 'False'))) (RULE ARRAY (BLOCK (ALT 'Array'))) (RULE IN (BLOCK (ALT 'In'))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOLEAN (BLOCK (ALT 'Boolean'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE RETURN (BLOCK (ALT 'Return'))) (RULE NULL (BLOCK (ALT 'Null'))) (RULE CLASS (BLOCK (ALT 'Class'))) (RULE VAL (BLOCK (ALT 'Val'))) (RULE VAR (BLOCK (ALT 'Var'))) (RULE CONSTRUCTOR (BLOCK (ALT 'Constructor'))) (RULE DESTRUCTOR (BLOCK (ALT 'Destructor'))) (RULE NEW (BLOCK (ALT 'New'))) (RULE BY (BLOCK (ALT 'By'))) (RULE LEFT_PAREN (BLOCK (ALT '('))) (RULE RIGHT_PAREN (BLOCK (ALT ')'))) (RULE LEFT_SQUARE_BRACKET (BLOCK (ALT '['))) (RULE RIGHT_SQUARE_BRACKET (BLOCK (ALT ']'))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE LEFT_CURLY_BRACKET (BLOCK (ALT '{'))) (RULE RIGHT_CURLY_BRACKET (BLOCK (ALT '}'))) (RULE SINGLE_QUOTE (RULEMODIFIERS fragment) (BLOCK (ALT '\''))) (RULE DOUBLE_QUOTE (RULEMODIFIERS fragment) (BLOCK (ALT '"'))) (RULE ESCAPE (BLOCK (ALT '\\' (BLOCK (ALT [bfrnt'"]) (ALT '\\'))))) (RULE OCTAL_NOTATION (RULEMODIFIERS fragment) (BLOCK (ALT '0'))) (RULE HEXA_NOTATION (RULEMODIFIERS fragment) (BLOCK (ALT '0x') (ALT '0X'))) (RULE BINARY_NOTATION (RULEMODIFIERS fragment) (BLOCK (ALT '0b') (ALT '0B'))) (RULE OCTAL_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9a-fA-F]))) (RULE HEXA_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-7]))) (RULE BINARY_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-1]))) (RULE DECIMAL_DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE EXPONENT (RULEMODIFIERS fragment) (BLOCK (ALT [eE] (? (BLOCK (ALT [-+]))) (+ (BLOCK (ALT DECIMAL_DIGIT)))))) (RULE INTEGER (BLOCK (ALT (? (BLOCK (ALT [-+]))) (BLOCK (ALT '0') (ALT [1-9] (* (BLOCK (ALT DECIMAL_DIGIT) (ALT '_'))))) {self.text = self.text.replace("_", "")}))) (RULE OCTAL_LITERALNESS (BLOCK (ALT OCTAL_NOTATION OCTAL_DIGIT))) (RULE HEXA_LITERALNESS (BLOCK (ALT HEXA_NOTATION HEXA_DIGIT))) (RULE BINARY_LITERALNESS (BLOCK (ALT BINARY_NOTATION BINARY_DIGIT))) (RULE FLOAT_LITERALNESS (BLOCK (ALT (+ (BLOCK (ALT INTEGER))) DOT (* (BLOCK (ALT DECIMAL_DIGIT))) (? (BLOCK (ALT EXPONENT)))) (ALT (+ (BLOCK (ALT INTEGER))) (? (BLOCK (ALT EXPONENT)))) (ALT DOT (+ (BLOCK (ALT DECIMAL_DIGIT))) (? (BLOCK (ALT EXPONENT)))))) (RULE BOOLEAN_LITERALNESS (BLOCK (ALT TRUE) (ALT FALSE))) (RULE STRING_LITERALNESS (BLOCK (ALT DOUBLE_QUOTE (* (BLOCK (ALT ESCAPE) (ALT .))) DOUBLE_QUOTE))) (RULE ERROR_CHAR (BLOCK (ALT . {raise ErrorToken (self.text)}))) (RULE UNCLOSE_STRING (BLOCK (ALT .))) (RULE ILLEGAL_ESCAPE (BLOCK (ALT .)))))
2022-01-12 16:30:56:717 action-translator LogManager.java:25 translate 
from lexererr import *

2022-01-12 16:30:56:735 action-translator LogManager.java:25 translate self.text = self.text.replace("_", "")
2022-01-12 16:30:56:735 action-translator LogManager.java:25 translate raise ErrorToken (self.text)
2022-01-12 16:30:56:803 semantics LogManager.java:25 tokens={EOF=-1, TEST=1, WHITE_SPACE=2, COMMENT=3, BREAK=4, CONTINUE=5, IF=6, ELSE_IF=7, ELSE=8, FOR_EACH=9, TRUE=10, FALSE=11, ARRAY=12, IN=13, INT=14, FLOAT=15, BOOLEAN=16, STRING=17, RETURN=18, NULL=19, CLASS=20, VAL=21, VAR=22, CONSTRUCTOR=23, DESTRUCTOR=24, NEW=25, BY=26, LEFT_PAREN=27, RIGHT_PAREN=28, LEFT_SQUARE_BRACKET=29, RIGHT_SQUARE_BRACKET=30, DOT=31, COMMA=32, SEMICOLON=33, LEFT_CURLY_BRACKET=34, RIGHT_CURLY_BRACKET=35, ESCAPE=36, INTEGER=37, OCTAL_LITERALNESS=38, HEXA_LITERALNESS=39, BINARY_LITERALNESS=40, FLOAT_LITERALNESS=41, BOOLEAN_LITERALNESS=42, STRING_LITERALNESS=43, ERROR_CHAR=44, UNCLOSE_STRING=45, ILLEGAL_ESCAPE=46}
2022-01-12 16:30:56:804 semantics LogManager.java:25 strings={'Break'=4, 'Continue'=5, 'If'=6, 'Elseif'=7, 'Else'=8, 'Foreach'=9, 'True'=10, 'False'=11, 'Array'=12, 'In'=13, 'Int'=14, 'Float'=15, 'Boolean'=16, 'String'=17, 'Return'=18, 'Null'=19, 'Class'=20, 'Val'=21, 'Var'=22, 'Constructor'=23, 'Destructor'=24, 'New'=25, 'By'=26, '('=27, ')'=28, '['=29, ']'=30, '.'=31, ','=32, ';'=33, '{'=34, '}'=35}
2022-01-12 16:30:56:807 LL1 LogManager.java:25 
DECISION 0 in rule init
2022-01-12 16:30:56:808 LL1 LogManager.java:25 look=[32, 35]
2022-01-12 16:30:56:809 LL1 LogManager.java:25 LL(1)? true
2022-01-12 16:30:56:809 LL1 LogManager.java:25 
DECISION 1 in rule value
2022-01-12 16:30:56:809 LL1 LogManager.java:25 look=[34, 1]
2022-01-12 16:30:56:809 LL1 LogManager.java:25 LL(1)? true
